The uppercase of this file name has the effect of disabling the code autocompletion and suggestions as you type.
Not sure why that is, since the .log extension already does not have an associated file type, but you do get
the annoyances when the filename and extension are in lowercase.

9 Aug 2021
Found another move to disallow:  When both source and dest are homogenous with the same color, do not move the
greater to the lesser.  This helped with the final printout of moves but interestingly, added 5 minutes to my
test case of 647; it seems that the Racks that it came to after making the 'stupid' move led to the solution
sooner that getting there the 'right' way.  At least it did when using the logic I've employed for the brute
force methodology.  Until I can find a smarter approach, willing to accept the downside and call it done;
would rather have the higher quality solution even though it took longer to get there.

8 Aug 2021 (birthday, in the cottage)
Coded in the second disallowed move from the two listed yesterday.
And then the first.  After some printout refactoring and fixing some minor oopsies, it finally began to
work, although I had to run it one last time after adding in the dump of the moves for a successful
sort (I had only been printing out the ~16K unsuccessful ones, not the one success.  Now - DONE!

7 Aug 2021
For a while, was stymied by a language restriction that you cannot alter a list while iterating through it.  So I
thought I had the answer by going back to recursion, but that just exhaused the processing stack; both ideas dead
ended.  Then arrived at a variation of the original idea, but do not iterate the list, just keep a reference to
the latest unprocessed instance, while processing the list even as it grows by also keeping an indexer outside
of the class doing the work.  This all worked, but then I finally arrived at the infinite loop of moves problem.
Thought I could solve that by disallowing identical tableaus but that only helps outside of the explorePossibleMove
processing, not within it, so it only solves a part of the problem.  This may be the last problem before having a
final solution.  Working it now..
----
So to solve the issue within a possibility exploration, now disallowing a move that has been made before, by first
checking for its presence in the 'currentRun' list.  This allowed the app to begin running continuously but now it
goes on for hours, finding more than 120K of new possible racks before I stopped it, still unfinished.
A printout of the currentRun showed that we only see the run of the final rack in the possibility chain and not
the run from the initial rack, so had to add that to the constructor.  Did that, and
then followed a random run of 38 moves thru the ipad app to see that there are some 'stupid' moves being made, that
greatly expand the processing needed and cause wasteful (try/put back) moves.  Now need to disallow a move:
1.  from the top of a non-full tube that contains all same color, to an empty tube.
2.  from a tube where the next one(s) down are the same color, to a tube that does not have the capacity for all of
    them.

5 Aug 2021
The finding of all possibilities is proceeding as a breadth-first search, while the trying of moves is depth-first.
Working on finding a way to make them both work.

4 Aug 2021
No longer sure that the answer here is recursion.  New idea about the approach is to take the initial tableau and make
a list of every possible single move from that point.  Then begin cycling thru those moves and after each one, snapshot
the tableau and make a new list of possibilities, to be added to the worklist.  Eventually we will either have found a
solution, or exhausted all possibilities.  The 'master list' will be a pair of 1: a tableau and 2: a list of possible
moves from that point.
----
Enabled git for this project, to commit and preserve the initial approach that took in some user input for user
specification of problem size.  Now that info is built in to the construction of the first tableau.
----
Continuing with finding all moves, how to avoid circular possibilities?  Need to review that master list each time
a move is considered, to ensure that the new tableau would not be a repetition of one that is already in the list.  This
means that tableaus should not be removed from the main list just because all their possibilities have been exhausted.
Current thought is that the shortest path would always be the one you arrived at first; need to verify that.  But if
not then when considering adding one you just take the one that has a shorter path to get there, vs just keeping the
one that is already there.
----
Ok, so this might be recursion after all; when a TubeRack construction goes off to list its possibilities and then
constructs more TubeRacks to cover those possibilities, that would be recursion.  Unless - the list growth occurs
after a new list is constructed.
----
Need to move the currentRun info into the TubeRack.  Each rack should have one and it should NOT be a static top level
member because it will become corrupted or lost with each reset.


3 Aug 2021
Changed from Integer colors to actual named enums.  This will make it easier to initialize in the future, without
the need to change integer values for every new puzzle, and printouts will not need translation from a number to a
color.  Major effect on all arrays, lists, etc.  Had to go from type <E> to type <ItemColor>.
-------
Made the adjustments needed to be able to get all the way through a first trial.  Now looking at how to set up and
initiate a second trial.  Haven't yet encountered/had to handle a second-level (or deeper) reset within a trial.

2 Aug 2021
Began the process of making a 'move', evaluating the result, and going to the next step after that.  Loops at this
stage are simplistic and fail quickly; need to refine so that a trial can get all the way to the 'end' and then
begin recursion in order to go on to the next trial.

1 Aug 2021
Did the LIFO as a new TestTube class, worked on getting the initial setup into the app, and showing the contents of
each tube.

30 July 2021 - A new Java project; an app to solve the iPad 'Ball Sort Puzzle' game.
Initial vision is to use a set of LIFO stacks and a brute-force approach.
Cleared up the 'no package' warning by setting the containing folder as 'sources' via module settings.
Upgraded my Java to 16.0.2.
Next:  Implement a LIFO, and more -


