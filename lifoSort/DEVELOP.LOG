The uppercase of this file name has the effect of disabling the code autocompletion and suggestions as you type.
Not sure why that is, since the .log extension already does not have an associated file type, but you do get
the annoyances when the filename and extension are in lowercase.

17 Aug 2021
Ok so maybe NOT done.  The solutions are taking too long; reconsidering the need to throw out the 'stupid' moves;
will need to try that, IF the current run started yesterday ever ends.  And also thinking about automating the
tube activation - upon an add, choose the first available tube, and deactivate before solving.


16 Aug 2021
0553 - Between later yesterday and right now, have implemented the ball addition logic to the active tube, and have
put in the code for clearing all tubes as well as added a new button to clear just one tube, as opposed to the earlier
idea of clicking on individual balls.  This decomplicates the mouse listener logic for the balls and gets us to the
final touches - all that is needed for a working app is to handle the 'Solve' button.  May not work on the 'Help'
button, since I'm the only user.  Also don't need to get fancy with button enablement; if the layout is not ready
then we just don't send a tableau over to the solution finder portion; can do a printout about that, since the button
will ultimately send control to the console at that point in any case.
----
Working on the 'solve' button, realize that the last two tubes in either layout should NOT be allowed to be added to.
----
So - added a gray background to those two tubes but that makes the four 'invisible' balls show up, looking like holes
in the tube because they don't have an outline, and the overall effect is pretty cool; I like it this way.  After
wiring in the 'solve' button with a simple actionhandler, it is all working, now with the optional UI mode, or using
the original text only hardcoded tableau mode.  The runs seem to be pretty long, now, but they ARE getting correct
results so - DONE!

15 Aug 2021
1109 - The layout switching is done.  Was problematic until started using removeAll().
Next will be to work on ball-adding to tubes, from bottom up.  Currently only the first ball is done correctly.
----
1713 - Did that, but hard to test by hard-coding.  A better test will be when the ball selection row is active and
we can see them going in in real-time.  But removal logic also not in yet.
Then, coded in the single tube selection logic (not the best hierarchy, but it works, to make a red outline).

14 Aug 2021
Haven't been writing down a lot of the planning or progress, but a LOT of progress has been made.  I now have
a ColorBall component, and have borrowed the ColumnPanel from Flashcards to get the rest of the way to the
first tableau layout of 14 tubes.  Still working on adding balls, switching to 11 tubes, etc.  No work at
all, yet, on activating any controls, but it looks great.
----
Now have both complete layouts; need to work on switching tube count as a result of the radio buttons.

10 Aug 2021
Decided to go ahead and add a UI whereby the initial tableau can be set.  Now, design, ideas, etc.

9 Aug 2021
Found another move to disallow:  When both source and dest are homogenous with the same color, do not move the
greater to the lesser.  This helped with the final printout of moves but interestingly, added 5 minutes to my
test case of 647; it seems that the Racks that it came to after making the 'stupid' move led to the solution
sooner that getting there the 'right' way.  At least it did when using the logic I've employed for the brute
force methodology.  Until I can find a smarter approach, willing to accept the downside and call it done;
would rather have the higher quality solution even though it took longer to get there.

8 Aug 2021 (birthday, in the cottage)
Coded in the second disallowed move from the two listed yesterday.
And then the first.  After some printout refactoring and fixing some minor oopsies, it finally began to
work, although I had to run it one last time after adding in the dump of the moves for a successful
sort (I had only been printing out the ~16K unsuccessful ones, not the one final success.  Now - DONE!

7 Aug 2021
For a while, was stymied by a language restriction that you cannot alter a list while iterating through it.  So I
thought I had the answer by going back to recursion, but that just exhaused the processing stack; both ideas dead
ended.  Then arrived at a variation of the original idea, but do not iterate the list, just keep a reference to
the latest unprocessed instance, while processing the list even as it grows by also keeping an indexer outside
of the class doing the work.  This all worked, but then I finally arrived at the infinite loop of moves problem.
Thought I could solve that by disallowing identical tableaus but that only helps outside of the explorePossibleMove
processing, not within it, so it only solves a part of the problem.  This may be the last problem before having a
final solution.  Working it now..
----
So to solve the issue within a possibility exploration, now disallowing a move that has been made before, by first
checking for its presence in the 'currentRun' list.  This allowed the app to begin running continuously but now it
goes on for hours, finding more than 120K of new possible racks before I stopped it, still unfinished.
A printout of the currentRun showed that we only see the run of the final rack in the possibility chain and not
the run from the initial rack, so had to add that to the constructor.  Did that, and
then followed a random run of 38 moves thru the ipad app to see that there are some 'stupid' moves being made, that
greatly expand the processing needed and cause wasteful (try/put back) moves.  Now need to disallow a move:
1.  from the top of a non-full tube that contains all same color, to an empty tube.
2.  from a tube where the next one(s) down are the same color, to a tube that does not have the capacity for all of
    them.

5 Aug 2021
The finding of all possibilities is proceeding as a breadth-first search, while the trying of moves is depth-first.
Working on finding a way to make them both work.

4 Aug 2021
No longer sure that the answer here is recursion.  New idea about the approach is to take the initial tableau and make
a list of every possible single move from that point.  Then begin cycling thru those moves and after each one, snapshot
the tableau and make a new list of possibilities, to be added to the worklist.  Eventually we will either have found a
solution, or exhausted all possibilities.  The 'master list' will be a pair of 1: a tableau and 2: a list of possible
moves from that point.
----
Enabled git for this project, to commit and preserve the initial approach that took in some user input for user
specification of problem size.  Now that info is built in to the construction of the first tableau.
----
Continuing with finding all moves, how to avoid circular possibilities?  Need to review that master list each time
a move is considered, to ensure that the new tableau would not be a repetition of one that is already in the list.  This
means that tableaus should not be removed from the main list just because all their possibilities have been exhausted.
Current thought is that the shortest path would always be the one you arrived at first; need to verify that.  But if
not then when considering adding one you just take the one that has a shorter path to get there, vs just keeping the
one that is already there.
----
Ok, so this might be recursion after all; when a TubeRack construction goes off to list its possibilities and then
constructs more TubeRacks to cover those possibilities, that would be recursion.  Unless - the list growth occurs
after a new list is constructed.
----
Need to move the currentRun info into the TubeRack.  Each rack should have one and it should NOT be a static top level
member because it will become corrupted or lost with each reset.


3 Aug 2021
Changed from Integer colors to actual named enums.  This will make it easier to initialize in the future, without
the need to change integer values for every new puzzle, and printouts will not need translation from a number to a
color.  Major effect on all arrays, lists, etc.  Had to go from type <E> to type <ItemColor>.
-------
Made the adjustments needed to be able to get all the way through a first trial.  Now looking at how to set up and
initiate a second trial.  Haven't yet encountered/had to handle a second-level (or deeper) reset within a trial.

2 Aug 2021
Began the process of making a 'move', evaluating the result, and going to the next step after that.  Loops at this
stage are simplistic and fail quickly; need to refine so that a trial can get all the way to the 'end' and then
begin recursion in order to go on to the next trial.

1 Aug 2021
Did the LIFO as a new TestTube class, worked on getting the initial setup into the app, and showing the contents of
each tube.

30 July 2021 - A new Java project; an app to solve the iPad 'Ball Sort Puzzle' game.
Initial vision is to use a set of LIFO stacks and a brute-force approach.
Cleared up the 'no package' warning by setting the containing folder as 'sources' via module settings.
Upgraded my Java to 16.0.2.
Next:  Implement a LIFO, and more -


