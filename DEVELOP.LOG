

22-23 Aug 2021
(after gaining more understanding from debug sessions) -
When a possible move is tried, a new rack may be created at that time but the
move that we are trying, that resulted in this new rack, will never be in the new rack's list of possibilities; it will
only ever be in the rack that spawned the new one, which will not even necessarily be this one, when a trial runs
deeper than the first level of possible moves.  This is why a new logic path was added, to allow for a bit of
backward-looking so that when an allowed new move is being tried, we search for it as a possibility in the rack that was
previously spawned and not in the rack that would be created if this move were to be accepted.  Code was added all
around, to support - in PossibleMove as well as TubeRack methods and fields.  Times improved minimally in all setups.
When those new racks finally come up for examination of their possibilities, at least one possibility in each of those
racks will have already been explored, except for the cases where the rack that was spawned is not allowing any further
moves, which can occur when there are no possibilities or when all its options are disallowed by moveOne().

21 Aug 2021
About just accepting the downside of duplicated effort - yes, I could do that and normally would, but at this
particular point in time we are on the verge of a month-long trip to the U.S. which is going to be a huge disruption in
my work schedule so I am feeling reluctant to get back to the WordPress site, yet there are still > 3 weeks to go
before the trip.  So you see what I'm getting at - I will stay on this project and refine it while I can.  Have now had
new ideas about adding a list to each rack, of the follow-on racks that it has created, and when a possibility is
explored, go into that rack and mark it as 'explored'.  Then when the rack is examined in the normal flow, if that poss
had already been explored it can be skipped.  Will probably need to also work on the PossibleMove class.  The key to
this proposed approach is that the overall list and the local list of Racks are just lists of references, so unlike
graphical components that can only go into one container, those references can be held in more than one logical list.
Will (re-)start soon...

20 Aug 2021
A long, intensive study of the output finally led me to a problem in the initial setup, that propagated itself over
to the hardcoded solution as well.  To prevent that in future runs, added a validateTableau() method that will run
from either start point.  Now, finally, getting the same results regardless of how the solution finder is started.
There may still be some improper printouts but for now will go back to just using the app and looking for the longest
run which at this point is 24 minutes and 16 seconds (setup651).
---
0828 Fixed the parentheses around 'slot'.  But still wondering why do we have multiple 'did not move' lines one
after another, without a new 'Considering/Trying' in between them - is this another potential area for improvement?
May look at that next, or let just  this lapse for a while.
----
Ok, looked at it right away, while still fresh.  Reason for multiple lines is that they occur after a trial move has
been posited, and the app is trying to find the next available move from there, not from the 'Considering'.  So,
there can be many such 'did not move' statements before the next 'Considering'.  App is working correctly.
But there IS some inefficiency - every time a trial move is made and then digs deeper, it will be trying one of the
possible moves of a follow-on tableau/rack, and that move will then be tried again when it is that rack's turn to be
possibility-explored.  Or it may have already been possibility-explored, in which case the current effort would not
be needed.  So there is ~some~ duplicate work being done; not sure what effect it has on runtimes but until there is
a greater need for speed, will deem that this downside is acceptable.

19 Aug 2021
The latest test - puzzle 652 - has run for more than 18 hours, and is still going.  Looking for more shortcuts,
what if the possible moves finder was more robust and threw out the ones that are currently failing upon trying?
Then the 'tries' would have to use the possibilities lists rather than doing their own search (if they can?).
It would be better, not to do the work twice.
The output file is now too big to read with notepad, wordpad, or even Word, even with all the 'Did not move' lines
disabled.  Installed notepad++.  This one was started via the new UI method; still haven't got confidence that this
somehow creates a problem.  I solved #652 on my own, in about two minutes.
----
Stopped it at 11:40, after about 22 hrs.  Noticed a problem in the printouts that the first attempt on a new set of
possibilities reports trying something else; indication of having gone off the rails.  Possibly need the loadRack()
unconditionally?

18 Aug 2021
So the non-debug run of setup651 with illogical moves being allowed, ran for almost exactly 12 hours.  Added an
elapsed time calculator, and found that when a duplicate tableau would be created, need to stop the exploration
at that point as well, since that exploration would occur when the avoided duplicate is explored.  This seems to
have cut times in less than half.  So now with illogicals once again disallowed and the new shortcut in place,
trying again...  (output has continued to be trimmed/improved).
----
And now, just over 25 minutes!  Much much better.  But isn't it just chance, that by filtering out some 'noise' that
otherwise still would have come up later in the processing, we encountered the solution sooner?  In that case there
are still initial tableaus that would take ~12 hours to solve; we just short-circuited THIS one (651).  Now will switch
back to better UI input methods and then testing later puzzles, to compare run times and outputs.  Maybe there is a
better explanation (other than pure chance/luck) for why the solution was found sooner when following this particular
order of rack examination.
----
One idea to explain the timing improvement:  The time needed to search the full list of racks for possible duplicates
is reduced by not adding so many new racks for moves that have not yet been explored.  But in reality, all that has
done is defer their addition to the list, UNLESS the solution is found in the earlier racks that are now not pushed
down.  This means that it is possible to have just as long of a run, when
the solution is NOT found in those earlier racks.
----
1319 Tube activation automation upon ball add - is done!  Ready to test new tableaus.

17 Aug 2021
Ok so maybe NOT done.  The solutions are taking too long; reconsidering the need to throw out the 'stupid' moves;
will need to try that, IF the current run started yesterday ever ends.  And also thinking about automating the
tube activation - upon an add, choose the first available tube, and deactivate before solving.
----
0702 - stopped it.  Yesterday start was (I believe) early afternoon.  Seems like something is wrong; need to dig deep
to find it.  Another item to add:  at the start of a user-entered solution, save a file that can be used to restart
the solution, without all the tedious entry.
----
Ok, now saving a file for possible re-run; can then paste it in for the next run.  As for run time - this may be
on me, operationally - Note to self:  It takes longer to run in debug mode than in a straightforward run.  I can get a
read on where we are in the process by clicking on the printout to stop it, as a better option than having a breakpoint.
And probably would run even faster from command-line vs via the IDE, and without output to console.
Still want the auto-sequencing of user data entry, tho.

16 Aug 2021
0553 - Between later yesterday and right now, have implemented the ball addition logic to the active tube, and have
put in the code for clearing all tubes as well as added a new button to clear just one tube, as opposed to the earlier
idea of clicking on individual balls.  This decomplicates the mouse listener logic for the balls and gets us to the
final touches - all that is needed for a working app is to handle the 'Solve' button.  May not work on the 'Help'
button, since I'm the only user.  Also don't need to get fancy with button enablement; if the layout is not ready
then we just don't send a tableau over to the solution finder portion; can do a printout about that, since the button
will ultimately send control to the console at that point in any case.
----
Working on the 'solve' button, realize that the last two tubes in either layout should NOT be allowed to be added to.
----
So - added a gray background to those two tubes but that makes the four 'invisible' balls show up, looking like holes
in the tube because they don't have an outline, and the overall effect is pretty cool; I like it this way.  After
wiring in the 'solve' button with a simple actionhandler, it is all working, now with the optional UI mode, or using
the original text only hardcoded tableau mode.  The runs seem to be pretty long, now, but they ARE getting correct
results so - DONE!

15 Aug 2021
1109 - The layout switching is done.  Was problematic until started using removeAll().
Next will be to work on ball-adding to tubes, from bottom up.  Currently only the first ball is done correctly.
----
1713 - Did that, but hard to test by hard-coding.  A better test will be when the ball selection row is active and
we can see them going in in real-time.  But removal logic also not in yet.
Then, coded in the single tube selection logic (not the best hierarchy, but it works, to make a red outline).

14 Aug 2021
Haven't been writing down a lot of the planning or progress, but a LOT of progress has been made.  I now have
a ColorBall component, and have borrowed the ColumnPanel from Flashcards to get the rest of the way to the
first tableau layout of 14 tubes.  Still working on adding balls, switching to 11 tubes, etc.  No work at
all, yet, on activating any controls, but it looks great.
----
Now have both complete layouts; need to work on switching tube count as a result of the radio buttons.

10 Aug 2021
Decided to go ahead and add a UI whereby the initial tableau can be set.  Now, design, ideas, etc.

9 Aug 2021
Found another move to disallow:  When both source and dest are homogenous with the same color, do not move the
greater to the lesser.  This helped with the final printout of moves but interestingly, added 5 minutes to my
test case of 647; it seems that the Racks that it came to after making the 'stupid' move led to the solution
sooner that getting there the 'right' way.  At least it did when using the logic I've employed for the brute
force methodology.  Until I can find a smarter approach, willing to accept the downside and call it done;
would rather have the higher quality solution even though it took longer to get there.

8 Aug 2021 (birthday, in the cottage)
Coded in the second disallowed move from the two listed yesterday.
And then the first.  After some printout refactoring and fixing some minor oopsies, it finally began to
work, although I had to run it one last time after adding in the dump of the moves for a successful
sort (I had only been printing out the ~16K unsuccessful ones, not the one final success.  Now - DONE!

7 Aug 2021
For a while, was stymied by a language restriction that you cannot alter a list while iterating through it.  So I
thought I had the answer by going back to recursion, but that just exhaused the processing stack; both ideas dead
ended.  Then arrived at a variation of the original idea, but do not iterate the list, just keep a reference to
the latest unprocessed instance, while processing the list even as it grows by also keeping an indexer outside
of the class doing the work.  This all worked, but then I finally arrived at the infinite loop of moves problem.
Thought I could solve that by disallowing identical tableaus but that only helps outside of the explorePossibleMove
processing, not within it, so it only solves a part of the problem.  This may be the last problem before having a
final solution.  Working it now..
----
So to solve the issue within a possibility exploration, now disallowing a move that has been made before, by first
checking for its presence in the 'currentRun' list.  This allowed the app to begin running continuously but now it
goes on for hours, finding more than 120K of new possible racks before I stopped it, still unfinished.
A printout of the currentRun showed that we only see the run of the final rack in the possibility chain and not
the run from the initial rack, so had to add that to the constructor.  Did that, and
then followed a random run of 38 moves thru the ipad app to see that there are some 'stupid' moves being made, that
greatly expand the processing needed and cause wasteful (try/put back) moves.  Now need to disallow a move:
1.  from the top of a non-full tube that contains all same color, to an empty tube.
2.  from a tube where the next one(s) down are the same color, to a tube that does not have the capacity for all of
    them.

5 Aug 2021
The finding of all possibilities is proceeding as a breadth-first search, while the trying of moves is depth-first.
Working on finding a way to make them both work.

4 Aug 2021
No longer sure that the answer here is recursion.  New idea about the approach is to take the initial tableau and make
a list of every possible single move from that point.  Then begin cycling thru those moves and after each one, snapshot
the tableau and make a new list of possibilities, to be added to the worklist.  Eventually we will either have found a
solution, or exhausted all possibilities.  The 'master list' will be a pair of 1: a tableau and 2: a list of possible
moves from that point.
----
Enabled git for this project, to commit and preserve the initial approach that took in some user input for user
specification of problem size.  Now that info is built in to the construction of the first tableau.
----
Continuing with finding all moves, how to avoid circular possibilities?  Need to review that master list each time
a move is considered, to ensure that the new tableau would not be a repetition of one that is already in the list.  This
means that tableaus should not be removed from the main list just because all their possibilities have been exhausted.
Current thought is that the shortest path would always be the one you arrived at first; need to verify that.  But if
not then when considering adding one you just take the one that has a shorter path to get there, vs just keeping the
one that is already there.
----
Ok, so this might be recursion after all; when a TubeRack construction goes off to list its possibilities and then
constructs more TubeRacks to cover those possibilities, that would be recursion.  Unless - the list growth occurs
after a new list is constructed.
----
Need to move the currentRun info into the TubeRack.  Each rack should have one and it should NOT be a static top level
member because it will become corrupted or lost with each reset.


3 Aug 2021
Changed from Integer colors to actual named enums.  This will make it easier to initialize in the future, without
the need to change integer values for every new puzzle, and printouts will not need translation from a number to a
color.  Major effect on all arrays, lists, etc.  Had to go from type <E> to type <ItemColor>.
-------
Made the adjustments needed to be able to get all the way through a first trial.  Now looking at how to set up and
initiate a second trial.  Haven't yet encountered/had to handle a second-level (or deeper) reset within a trial.

2 Aug 2021
Began the process of making a 'move', evaluating the result, and going to the next step after that.  Loops at this
stage are simplistic and fail quickly; need to refine so that a trial can get all the way to the 'end' and then
begin recursion in order to go on to the next trial.

1 Aug 2021
Did the LIFO as a new TestTube class, worked on getting the initial setup into the app, and showing the contents of
each tube.

30 July 2021 - A new Java project; an app to solve the iPad 'Ball Sort Puzzle' game.
Initial vision is to use a set of LIFO stacks and a brute-force approach.
Cleared up the 'no package' warning by setting the containing folder as 'sources' via module settings.
Upgraded my Java to 16.0.2.
Next:  Implement a LIFO, and more -


